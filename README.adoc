= Another Keyboard Layer (AKL)
:nofooter:
:toc: preamble
:imagesdir: assets
:experimental:
ifdef::commit-hash[]
:revdate: {docdatetime}
:revremark: Commit: {commit-hash}
endif::[]
// Translations
:!figure-caption:
:toc-title: Inhaltsverzeichnis
:note-caption: Anmerkung
// Source Code highlighting
:source-highlighter: rouge
:rouge-style: base16.light

////
Generate documentation with rendered diagrams by executing the following script.

    ./build-documentation.sh

An installation of the ruby version of asciidoctor with the diagram extension
and the rouge syntax highlighter is required:

- https://docs.asciidoctor.org/asciidoctor/latest/install/ruby-packaging/
- https://docs.asciidoctor.org/diagram-extension/latest/#installation
- https://docs.asciidoctor.org/asciidoctor/latest/syntax-highlighting/rouge/
////

Programm das einen weiteren Tastaturlayer emuliert.

Auf diesen virtuellen Layer können schwer zu erreichende Tasten oder
komplizierte Tastenkombinationen gelegt werden. Dann kann auf den Layer mit
einer konfigurierbaren Taste wie z. B. kbd:[CapsLock] gewechselt werden.

== Features

- Konfigurierbare Layer-Umschalttaste
- Standarttaste die gesendet wird, für den Fall das keine Taste im virtuellen
Layer gedruckt wurde.
- Sprachunabhängige Implementation der Tastenwerte
- Textbasierte und auch graphische Konfigurationsmöglichkeiten
- Konfigurierbares Starten mit dem System

== Komponenten

Um GUI-Entwicklung mit C# und Interfacing von Native Bibliotheken, die in
anderen Programmiersprachen geschrieben wurden, mit C# zu lernen, wird das
Programm in folgende Komponenten aufgeteilt.

=== Kern (`akl-core-system-lib`)

Der Kern wird in Rust geschrieben und wird direkt mit dem jeweiligen
Betriebssystem interagieren, um global Tastaturevents abzuhören und wie
konfiguriert zu verändern. Außerdem wird der Kern ein C Interface bereit stellen
und im Build-Vorgang automatisch CSharp Bindings für dieses generieren.

.Relevante Tools, Bibliotheken und Ressourcen
- https://github.com/Narsil/rdev
- https://github.com/Cysharp/csbindgen
- https://learn.microsoft.com/en-us/windows/win32/inputdev/keyboard-input[Win32 Keyboard Input]

=== Graphische Benutzerschnittstelle (`AKL.Gui`)

Die graphische Benutzerschnittstelle bietet eine Möglichkeit den virtuellen
Layer komplett zu konfigurieren und diesen zu aktivieren oder zu deaktivieren.
Zu konfigurierende Werte sind unter anderem der Umschalter, die Taste welche bei
schnellem Drücken des Umschalters ohne eine weitere Taste simuliert werden soll
und die eigentlichen Mappings. Des Weiteren dient dieses Modul dem Erlernen der
GUI Programmierung mit dem https://github.com/AvaloniaUI/Avalonia[Avalonia]
Framework, welches von der Struktur sehr stark
https://learn.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-wpf?view=vs-2022#what-is-wpf[WPF]
ähnelt.

=== Textbasierte Benutzerschnittstelle (`AKL.Cli`)

Zusätzlich zur graphischen Schnittstelle soll die textbasierte
Benutzerschnittstelle ein kleiner Wrapper um den Kern sein, der diesen nur mit
Hilfe der gespeicherten Konfiguration vom GUI initialisiert, außerdem sollte
für die Implementierung, Microsofts eigens für das Entwickeln von CLIs erstellte
Bibliothek https://github.com/dotnet/command-line-api[System.CommandLine]
verwendet werden.

=== Gemeinsame Funktionalität von Gui und Cli (`AKL.Common`)

Dieses Modul sollte das Parsen und Schreiben der Konfigurationsdatei als auch
die Interaktion mit `akl-core-system-lib` übernehmen, damit keine Logik
unnötigerweise dupliziert wird.

Nachdem Verarbeiten der Konfiguration sollten die Einstellungen falls nötig 
automatisch angewendet werden z. b. Autostart An / Aus.

NOTE: Die Konfiguration soll im https://en.wikipedia.org/wiki/TOML[TOML] format
gespeichert werden und in C# mit https://github.com/xoofx/Tomlyn[Tomlyn]
verarbeitet werden.

.Definition der Api für Cli und Gui
[plantuml, target="common-api-definition", format=svg]
....
@startuml
!theme reddress-darkblue

enum SpecialKeys {
    Ctrl,
    Shift,
    Space,
    ...
}

note left of SpecialKeys::...
Steht für die restlichen Special / Named Keys, allerdings
macht es keinen Sinn diese hier aufzulisten.
end note

enum KeyKind {
    Simple,
    Special
}

class Key {
    {field} -SpecialKey? specialKey
    {field} -Char? unicodeKey
    {field} -KeyKind kind
    {static} {method} +Key TryParse(string raw)
}

Key *-- SpecialKeys
Key *-- KeyKind

class KeyCombination {
    {field} -Key[] keys;
    {static} {method} +KeyCombination TryParse(string raw)
}

note top of KeyCombination
Jede Tastenkombination kann maximal
aus 4 Tasten bestehen. Leider gibt
es keinen ergonomischen Weg dies in
C# Klassen darzustellen.
end note

KeyCombination o-- Key

class VirtualLayer {
    {field} +bool Autostart
    {field} +Key SwitchKey
    {field} +KeyCombination? DefaultCombination
    {field} +Dictionary<KeyCombination, KeyCombination> Mappings
    {method} +Update()
}

VirtualLayer o- KeyCombination
VirtualLayer o- Key

class AklConfiguration {
    {field} -FileInfo file
    {field} -Toml configuration
    {static} {method} +AklConfiguration ReadFromFile(FileInfo file)
    {static} {method} +AklConfiguration WithSaveDefault(FileInfo output)
    {method} +VirtualLayer TryParse()
    {method} +bool SaveToFile()
}

VirtualLayer -- AklConfiguration

@enduml
....

=== Überblick über die Beziehungen der Komponenten

[plantuml, target="components-overview", format=svg]
....
@startuml
!theme reddress-darkblue

node "Operating System" {
    interface "Raw keyboard events" as keyboard

    note bottom of keyboard
        Implementation
        is os dependent.
    end note
}

component "Core Library (""akl-core-system-library"")" as core

interface "Toml Configuration" as config
component "Shared Functionality (""AKL.Common"")" as common

component "Main User Interface (""AKL.Gui"")" as gui
component "Basic Cli Wrapper (""AKL.Cli"")" as cli

gui --> common : uses
cli --> common : uses

common --> core : configures, starts and stops
config <- common : writes and reads

note left of core
    Implements the
    configurable
    virtual layer.
end note

core --> keyboard : interacts with

@enduml
....

== Build Anweisungen

Das Gui und die Cli können mit `dotnet publish -c Debug` für die eigene Platform
gebaut werden. Wenn die `Release`-Konfiguration verwendet wird (`dotnet publish 
-c Release`) wird auch für die jeweils andere Platform gebaut werden, allerdings
ist dieser Prozess nicht sehr stabil und kann auf Grund von vielen Variablen
fehlschlagen.

.Anforderungen
- https://dotnet.microsoft.com/en-us/download/dotnet/7.0[.NET 7.0 SDK]
- https://www.rust-lang.org/tools/install[Rustlang]
- **[Optional]** `rust-toolchain`-Targets `x86_64-pc-windows-gnu` und
`x86_64-unknown-linux-gnu` für crossplatform release builds

== Konfigurationsdatei

Die folgende Konfiguration sollte dem Benutzer über das Gui möglich sein, 
allerdings könnte er die Datei auch direkt verändern und das Program mit der 
Cli starten.

.Standartkonfigurationsdatei mit Kommentaren
[source, toml]
----
include::AKL.Common/default-config.toml[]
----
