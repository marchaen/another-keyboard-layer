= Another Keyboard Layer (AKL)
:nofooter:
:toc: preamble
:imagesdir: assets
:experimental:
ifdef::commit-hash[]
:revdate: {docdatetime}
:revremark: Commit: {commit-hash}
endif::[]
// Translations
:!figure-caption:
:toc-title: Inhaltsverzeichnis
:note-caption: Anmerkung
// Source Code highlighting
:source-highlighter: rouge
:rouge-style: base16.light

////
Generate documentation with rendered diagrams by executing the following script.

    ./build-documentation.py

An installation of the ruby version of asciidoctor with the diagram extension
and the rouge syntax highlighter and python3 is required:

- https://docs.asciidoctor.org/asciidoctor/latest/install/ruby-packaging/
- https://docs.asciidoctor.org/diagram-extension/latest/#installation
- https://docs.asciidoctor.org/asciidoctor/latest/syntax-highlighting/rouge/
////

Programm das einen weiteren Tastaturlayer emuliert.

Auf diesen virtuellen Layer können schwer zu erreichende Tasten oder
komplizierte Tastenkombinationen gelegt werden. Dann kann auf den Layer mit
einer konfigurierbaren Taste wie z. B. kbd:[CapsLock] gewechselt werden.

== Features

- Konfigurierbare Layer-Umschalttaste
- Standarttaste die gesendet wird, für den Fall das keine Taste im virtuellen
Layer gedrückt wurde.
- Sprachunabhängige Implementation der Tastenerkennung
- Textbasierte und auch graphische Konfigurationsmöglichkeiten
- Konfigurierbares Starten mit dem System

== Komponenten

Um GUI-Entwicklung mit C# und Interfacing von Native Bibliotheken, die in
anderen Programmiersprachen geschrieben wurden, mit C# zu lernen, wird das
Programm in folgende Komponenten aufgeteilt.

=== Kern (`akl-core-system-lib`)

Der Kern wird in Rust geschrieben und wird direkt mit dem jeweiligen
Betriebssystem interagieren, um global Tastaturevents abzuhören und wie
konfiguriert zu verändern. Außerdem wird der Kern ein C Interface bereit stellen
und im Build-Vorgang automatisch CSharp Bindings für dieses generieren.

.Relevante Tools, Bibliotheken und Ressourcen
- https://github.com/Narsil/rdev
- https://github.com/Cysharp/csbindgen
- https://learn.microsoft.com/en-us/windows/win32/inputdev/keyboard-input[Win32 Keyboard Input]

==== Abstraktion der Tastaturanschläge in Events

Darstellung der Verarbeitung der Tastaturanschläge unabhängig vom
Betriebssystem.

.Strukturierung
[plantuml, target="keyboard-input-event-abstraction", format=svg]
....
@startuml
!theme reddress-darkblue

enum Key {
    Text(char)
    Virtual(VirtualKey)
}

enum Action {
    Press
    Release
}

class Event {
    key: Key
    action: Action
}

enum ResponseAction {
    Nothing
    Block
    ReplaceWith(KeyCombination)
}

class EventProcessor {
    switch_key: Key,
    default_combination: Option<KeyCombination>,
    mappings: HashMap<KeyCombination, KeyCombination>,
    currently_pressed: Vec<Key>,
    block_events: bool,
    key_combination_executed: bool,
    +process(event: Event) -> ResponseAction
}

class NativeInputHook {
    {static} processor: EventProcessor

    ## native_input_handling ##

}

note right of NativeInputHook
Zuständig für das Parsen von
Rohevents und Ausführung von
aus dem Processing entstehenden
ResponseActions.
end note

Event *- Key
Action -* Event
EventProcessor - ChangeEventRequest
EventProcessor -- Event
NativeInputHook -- EventProcessor : uses to process events

@enduml
....

.Verarbeitung von Events
[plantuml, target="keyboard-input-event-flow", format=svg]
....
@startuml
!theme reddress-darkblue

start

if (Action is **press**?) then (yes)
    if (Key is switch key?) then (yes)
        :Set block events = true;
        :Clear currently pressed keys;
        :Return block event>
        detach
    else (no)
    endif

    if (Don't block events?) then (yes)
        :Return don't change event>
        detach
    else (no)
    endif

    :Add key to currently pressed keys;
    :Create key combination from pressed keys;

    if (Key combination is target for replacement?) then (yes)
        :Set key combination executed = true;
        :Remove current key from currently pressed;
        :Return replace with replacement combination>
        detach
    else (no)
    endif

    :Return block event>
elseif (Action is **release**?) then (yes)
    if (Key is switch key?) then (yes)
        :Set block events = false;

        if (Not key combination executed and default combination is set?) then (yes)
            :Return replace with default combination>
            detach
        else (no)
        endif
        
        :Reset key combination executed flag;
        :Return block event>
        detach
    else (no)
        if (Key in currently pressed?) then (yes)
            :Remove key from currently pressed keys;

            if (Block events is true?) then (yes)
                :Return block event>
                detach
            else (no)
            endif
        else (no)
        endif
    endif

    :Return don't change event>
else (invalid action data)
    :Skip event;
    detach
endif

stop

@enduml
....

=== Graphische Benutzerschnittstelle (`AKL.Gui`)

Die graphische Benutzerschnittstelle bietet eine Möglichkeit den virtuellen
Layer komplett zu konfigurieren und diesen zu aktivieren oder zu deaktivieren.
Zu konfigurierende Werte sind unter anderem der Umschalter, die Taste welche bei
schnellem Drücken des Umschalters ohne eine weitere Taste simuliert werden soll
und die eigentlichen Mappings. Des Weiteren dient dieses Modul dem Erlernen der
GUI Programmierung mit dem https://github.com/AvaloniaUI/Avalonia[Avalonia]
Framework, welches von der Struktur sehr stark
https://learn.microsoft.com/en-us/visualstudio/get-started/csharp/tutorial-wpf?view=vs-2022#what-is-wpf[WPF]
ähnelt.

=== Textbasierte Benutzerschnittstelle (`AKL.Cli`)

Zusätzlich zur graphischen Schnittstelle soll die textbasierte
Benutzerschnittstelle ein kleiner Wrapper um den Kern sein, der diesen nur mit
Hilfe der gespeicherten Konfiguration vom GUI initialisiert, außerdem sollte
für die Implementierung, Microsofts eigens für das Entwickeln von CLIs erstellte
Bibliothek https://github.com/dotnet/command-line-api[System.CommandLine]
verwendet werden.

==== Verfügbare Optionen (Englisch)

include::Manpage.adoc[tags=cli-options]

==== Visualisierung

[plantuml, target="cli-program-flow", format=svg]
....
@startuml
!theme reddress-darkblue

start

:Parse cli arguments;

if (Config path overriden?) then (yes)
    :Use custom config path;
else (no)
    :Use default config path;
endif

if (Config file exists?) then (no)
    if (Custom path set?) then (yes)
        :Print error message>
        :Exit program early;
        detach
    else (no)
        :Save default configuration;
    endif
else (yes)
endif

:Load configuration file;

if (Parsing config sucessfull?) then (no)
    :Print error message with cause>
    :Exit program early;
    detach
else (yes)
    if (Live reload activated?) then (yes)
        :Start file watcher in background thread;
        :Create callback for updating the virtual layer;
    else (no)
    endif

    :Start virtual layer;
    :Block until receiving Ctrl + C;
endif

stop

@enduml
....

=== Gemeinsame Funktionalität von Gui und Cli (`AKL.Common`)

Dieses Modul sollte das Parsen und Schreiben der Konfigurationsdatei als auch
die Interaktion mit `akl-core-system-lib` übernehmen, damit keine Logik
unnötigerweise dupliziert wird.

Nachdem Verarbeiten der Konfiguration sollten die Einstellungen falls nötig 
automatisch angewendet werden z. b. Autostart An / Aus.

NOTE: Die Konfiguration soll im https://en.wikipedia.org/wiki/TOML[TOML] format
gespeichert werden und in C# mit https://github.com/xoofx/Tomlyn[Tomlyn]
verarbeitet werden.

.Definition der Api für Cli und Gui
[plantuml, target="common-api-definition", format=svg]
....
@startuml
!theme reddress-darkblue

enum VirtualKeyCode {
    Control,
    Shift,
    Space,
    ...
}

note left of VirtualKeyCode::...
Steht für die restlichen Special / Named Keys, allerdings
macht es keinen Sinn diese hier aufzulisten.
end note

enum KeyKind {
    Text,
    Virtual
}

class Key {
    {field} -VirtualKeyCode? virtualKey
    {field} -Char? textKey
    {field} -KeyKind kind
    {static} {method} +Key TryParse(string raw)
}

class KeyCombination {
    {field} -Key[] keys;
    {static} {method} +KeyCombination TryParse(string raw)
}

note top of KeyCombination
Jede Tastenkombination kann maximal
aus 4 Tasten bestehen. Leider gibt
es keinen ergonomischen Weg dies in
C# Klassen darzustellen.
end note

class AklConfiguration {
    {field} -TomlAklConfiguration origin;
    {field} +bool Autostart
    {field} +Key SwitchKey
    {field} +KeyCombination? DefaultCombination
    {field} +Dictionary<KeyCombination, KeyCombination> Mappings
}

note left of AklConfiguration::TomlAklConfiguration
Internes Model für die De-/Serialization
in Toml mit Tomlyn.
end note

class VirtualLayer {
    {field} +AklConfiguration Configuration
    {method} +Update()
}

class AklConfigurationProvider {
    {field} -FileInfo file
    {field} -AklConfiguration configuration
    {static} {method} +AklConfigurationProvider LoadFromFile(FileInfo file)
    {method} +AklConfiguration GetConfiguration()
    {method} +void SaveToFile()
}

Key *-- VirtualKeyCode
Key *-- KeyKind

KeyCombination o-- Key

AklConfiguration o- KeyCombination
AklConfiguration o- Key

AklConfigurationProvider --> AklConfiguration : loads and saves
VirtualLayer *-- AklConfiguration : needs

@enduml
....

=== Überblick über die Beziehungen der Komponenten

[plantuml, target="components-overview", format=svg]
....
@startuml
!theme reddress-darkblue

node "Operating System" {
    interface "Raw keyboard events" as keyboard

    note bottom of keyboard
        Implementation
        is os dependent.
    end note
}

component "Core Library (""akl-core-system-library"")" as core

interface "Toml Configuration" as config
component "Shared Functionality (""AKL.Common"")" as common

component "Main User Interface (""AKL.Gui"")" as gui
component "Basic Cli Wrapper (""AKL.Cli"")" as cli

gui --> common : uses
cli --> common : uses

common --> core : configures, starts and stops
config <- common : writes and reads

note left of core
    Implements the
    configurable
    virtual layer.
end note

core --> keyboard : interacts with

@enduml
....

== Build Anweisungen

Das Gui und die Cli können mit `dotnet publish -c Release` für die eigene 
Platform gebaut werden. Wenn man die Option `--os **<OS>**` am Ende hinzufügt,
kann man für die jeweils andere Platform bauen (gültige Werte sind `win` /
`linux`).

.Anforderungen
- https://dotnet.microsoft.com/en-us/download/dotnet/7.0[.NET 7.0 SDK]
- https://www.rust-lang.org/tools/install[Rustlang]
- https://github.com/cross-rs/cross[cross]

=== Dokumentation

Folgender Befehl generiert HTML-Dokumente aus roh Text von Source Code und
den AsciiDocs.

  ./build-documentation.py

.Anforderungen
- https://www.python.org/downloads/[Python3]

== Konfigurationsdatei

Die folgende Konfiguration sollte dem Benutzer über das Gui möglich sein, 
allerdings könnte er die Datei auch direkt verändern und das Program mit der 
Cli starten.

.Standartkonfigurationsdatei mit Kommentaren
[source, toml]
----
include::AKL.Common/default-config.toml[]
----
